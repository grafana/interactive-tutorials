<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LogQL 101 - Interactive Guide</title>
</head>
<body>
  <h1>Welcome to LogQL 101! üìù</h1>
  
  <p>Welcome to your hands-on introduction to LogQL - Grafana Loki's powerful query language for logs! This interactive guide will teach you how to search, filter, and analyze logs like a pro.</p>

  <p>LogQL is inspired by PromQL (Prometheus Query Language) and provides a simple yet powerful way to query and aggregate log data. Let's get started!</p>

  <h2>üéØ What You'll Learn</h2>
  
  <ul>
    <li>üîç <strong>Basic log queries</strong> - Search and filter logs</li>
    <li>üè∑Ô∏è <strong>Label selectors</strong> - Filter by metadata</li>
    <li>üìä <strong>Log aggregations</strong> - Count and summarize log data</li>
    <li>‚ö° <strong>Advanced patterns</strong> - Parse and extract values from logs</li>
  </ul>

  <h2>üöÄ Let's Get Started</h2>
  
  <p>In this tutorial, you'll learn how to craft powerful LogQL queries to extract insights from your log data. We'll start with simple queries and progressively build up to more advanced use cases.</p>

  <h2>1. üìö Select Your Data Source</h2>
  
  <p>Before we can query logs, we need to select a Loki data source. The data source picker allows you to choose which Loki instance to query against.</p>

  <span id="select-datasource" class="interactive" data-targetaction="sequence" data-reftarget="span#select-datasource">
    <ul>
      <li class="interactive" 
          data-targetaction="multistep"
          data-requirements="exists-reftarget">
        <span class="interactive" 
              data-targetaction="highlight" 
              data-reftarget='input[data-testid="data-testid Select a data source"]'>
        </span>
        <span class="interactive" 
              data-targetaction="button" 
              data-reftarget="LokiNGINXLogs">
        </span>
        <span class="interactive-comment">This opens the data source picker and selects the Loki instance used for this tutorial.</span>
        Click the <strong>data source picker</strong>, then select <strong>LokiNGINXLogs</strong>.
      </li>
    </ul>
  </span>

  <h2>2. ‚è±Ô∏è Set a Time Range (Recommended)</h2>

  <p>LogQL queries always run over a <strong>time range</strong>. If your results look empty (or too noisy), the time range is one of the first things to check.</p>
  <p>For this tutorial, set your time range to something like <strong>Last 24 hours</strong> (or <strong>Last 1 hour</strong>) so you have enough data to explore.</p>
  <blockquote>Tip: Grafana also caps log results (often at <strong>1000 lines</strong>). Narrowing with labels and filters is the normal workflow.</blockquote>

  <span id="time-range" class="interactive" data-targetaction="sequence" data-reftarget="span#time-range">
    <ul>
      <li class="interactive"
          data-reftarget='button[data-testid="data-testid TimePicker Open Button"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">The <strong>time range picker</strong> controls which time window your query searches. LogQL results are always scoped to this range.</span>
        Click the <strong>time range picker</strong> (the clock icon) to open the time selection menu.
      </li>
      <li class="interactive"
          data-reftarget='#TimePickerContent label:contains("Last 24 hours")'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Selecting a recent time range ensures you have log data to work with. You can always adjust this later.</span>
        Select <strong>Last 24 hours</strong> from the quick ranges.
      </li>
    </ul>
  </span>

  <h2>3. ‚úçÔ∏è Write Your First LogQL Query</h2>
  
  <p>Now that we have our data source selected and Code mode enabled, let's write our first LogQL query! Every LogQL query starts with a label selector enclosed in curly braces.</p>

  <span id="first-query" 
        class="interactive" 
        data-targetaction="sequence" 
        data-reftarget="span#first-query">
    <ul>
      <li class="interactive" 
          data-reftarget='div[data-testid="QueryEditorModeToggle"] input[id^="option-code-radiogroup"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">The <strong>Code mode</strong> allows you to write LogQL queries directly as text, giving you full control over the query syntax. This is perfect for learning LogQL's powerful query language.</span>
        Switch to <strong>Code</strong> mode by clicking the raw query toggle to write LogQL directly.
      </li>
      <li class="interactive" 
          data-reftarget="textarea.inputarea"
          data-targetaction="formfill" 
          data-targetvalue='{service_name="nginx_access_log"}'
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Always start a LogQL query with a label selector. They always appear within curly braces.</span>
        Write your first query by typing <code>{service_name="nginx_access_log"}</code> into the query field. 
        This query selects all log lines from the Nginx access log service. Label selectors use the format <code>{label_name="value"}</code> to filter logs by specific attributes. Add as many label selectors as you can to filter your results down faster!
      </li>
      <li class="interactive" 
          data-reftarget='button[aria-label="Run query"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">The <strong>Run query</strong> button executes your LogQL query and displays the results. This is how you see the actual log data that matches your query criteria.</span>
        Click the <strong>Run query</strong> button to execute your LogQL query and see the results.
      </li>
      <li class="interactive" 
          data-reftarget='div[data-testid="data-testid panel content"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget"
          data-doit="false">
        <span class="interactive-comment">The <strong>panel content</strong> area displays the results of your LogQL query. This is where you can see the actual log data that matches your query criteria.</span>
        Notice the <strong>panel content</strong> area where your query results are displayed. You can see that the query returned 1000 log lines, which is the default limit. Let's try to narrow down our search further.
      </li>
    </ul>

    <p>The <code>|=</code> operator is a filter expression used to filter log lines by the presence of a specific string. Let's use it to try to find HTTP 500 errors in the logs.</p>

    <ul>
      <li class="interactive" 
          data-reftarget="textarea.inputarea"
          data-targetaction="formfill" 
          data-targetvalue='{service_name="nginx_access_log", host="appfelstrudel"} |= "500"'
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Let's refine our query by adding more specific filters. We're adding a <strong>host</strong> label selector to filter by a specific server, and using the <strong>line filter</strong> <code>|= "500"</code> to only show log entries containing "500" (HTTP 500 errors).</span>
        Type a more specific query: <code>{service_name="nginx_access_log", host="appfelstrudel"} |= "500"</code> to filter for 500 errors from a specific host.
      </li>
      <li class="interactive" 
          data-reftarget='button[data-testid="data-testid RefreshPicker run button"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Now let's execute this refined query to see the filtered results.</span>
        Click the <strong>Run query</strong> button to execute the refined query and see the filtered results.
      </li>
    </ul>

    <p>Oops! We meant to filter for HTTP 500 errors, but the query returns lines that have "500" anywhere in the body. We'll have to be more specific.</p>

    <ul>
      <li class="interactive" 
          data-reftarget="textarea.inputarea"
          data-targetaction="formfill" 
          data-targetvalue='{service_name="nginx_access_log", host="appfelstrudel"} |= "500" != "200"'
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Let's combine both approaches! We'll use <strong>|= "500"</strong> to include lines containing "500" and <strong>!= "200"</strong> to exclude lines containing "200". This gives us a more precise filter for HTTP 500 errors.</span>
        Type a combined query: <code>{service_name="nginx_access_log", host="appfelstrudel"} |= "500" != "200"</code> to filter for lines containing "500" but not "200".
      </li>
      <li class="interactive" 
          data-reftarget='button[data-testid="data-testid RefreshPicker run button"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Now let's execute this combined query to see the filtered results that contain "500" but not "200".</span>
        Click the <strong>Run query</strong> button to execute the query and see the filtered error logs.
      </li>
    </ul>
  </span>

  <p>Well, that narrows it down further-- we're now only seeing lines that have a "500" and do not have "200". But there's still a better way to write this query.</p>

  <h2>4. Use JSON parsing for precise filtering</h2>

  <span id="json-query" 
        class="interactive" 
        data-targetaction="sequence" 
        data-reftarget="span#json-query">

    <p>String filters (<code>|=</code>, <code>!=</code>) are quick, but they can match the wrong thing.</p>
    <p>If your log lines are JSON, it's usually better to <strong>parse</strong> the JSON and filter by a specific field.</p>

    <ul>
      <li class="interactive" 
          data-targetaction="multistep"
          data-requirements="exists-reftarget">
        <span class="interactive" 
              data-targetaction="highlight" 
              data-reftarget="textarea.inputarea">
        </span>
        <span class="interactive" 
              data-targetaction="formfill" 
              data-reftarget="textarea.inputarea"
              data-targetvalue='{service_name="nginx_access_log", host="appfelstrudel"} | json | status = "500"'>
        </span>
        <span class="interactive-comment">Here's a much better approach! We'll use the <strong>| json</strong> parser to extract structured data from the log lines, then filter by the <strong>status</strong> field directly. This is more precise than string matching.</span>
        Type a better query: <code>{service_name="nginx_access_log", host="appfelstrudel"} | json | status = "500"</code> to parse JSON and filter by the status field.
      </li>
      <li class="interactive" 
          data-reftarget='button[data-testid="data-testid RefreshPicker run button"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Now let's execute this JSON-based query to see the precise HTTP 500 error logs.</span>
        Click the <strong>Run query</strong> button to execute the JSON parsing query and see the filtered results.
      </li>
    </ul>
  </span>

  <h2>5. üßπ Make Results Easier to Read (Line Formatting)</h2>

  <p>Once you've extracted fields (like <code>status</code>) you can format each log line to show just what you care about. This makes scanning results much easier.</p>

  <span id="line-format" 
        class="interactive" 
        data-targetaction="sequence" 
        data-reftarget="span#line-format">
    <ul>
      <li class="interactive" 
          data-targetaction="multistep"
          data-requirements="exists-reftarget">
        <span class="interactive" 
              data-targetaction="highlight" 
              data-reftarget="textarea.inputarea">
        </span>
        <span class="interactive" 
              data-targetaction="formfill" 
              data-reftarget="textarea.inputarea"
              data-targetvalue='{service_name="nginx_access_log", host="appfelstrudel"} | json | status = "500" | line_format "{{.status}} {{.request_uri}}"}'>
        </span>
        <span class="interactive-comment"><code>line_format</code> changes how each result line is displayed. It doesn't change which lines match ‚Äî it just makes them easier to read.</span>
        Add <code>line_format</code> to make the results easier to scan:<br>
        <code>{service_name="nginx_access_log", host="appfelstrudel"} | json | status = "500" | line_format "{{.status}} {{.request_uri}}"</code><br>
        This shows the HTTP status and the requested URL for each matching log line.
      </li>
      <li class="interactive" 
          data-reftarget='button[data-testid="data-testid RefreshPicker run button"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Run the query again to see formatted output.</span>
        Click <strong>Run query</strong> to see the formatted results.
      </li>
    </ul>
  </span>

  <h2>6. üß© Regex (Last Resort)</h2>

  <p>Regular expressions are powerful, but they're usually the <strong>most expensive</strong> and hardest to maintain. Prefer <strong>label selectors</strong> and <strong>JSON parsing</strong> when you can.</p>
  <p>Use regex when logs are unstructured and you <em>can't</em> reliably parse fields.</p>

  <span id="regex-last-resort" 
        class="interactive" 
        data-targetaction="sequence" 
        data-reftarget="span#regex-last-resort">
    <ul>
      <li class="interactive" 
          data-targetaction="multistep"
          data-requirements="exists-reftarget">
        <span class="interactive" 
              data-targetaction="highlight" 
              data-reftarget="textarea.inputarea">
        </span>
        <span class="interactive" 
              data-targetaction="formfill" 
              data-reftarget="textarea.inputarea"
              data-targetvalue='{service_name="nginx_access_log", host="appfelstrudel"} | json | status = "500" |~ "id/[0-9]+/"'>
        </span>
        <span class="interactive-comment"><code>|~</code> filters log lines by a regular expression match. Here we combine JSON parsing with regex to find 500 errors on URIs with numeric IDs.</span>
        Find HTTP 500 errors on URIs like <code>/id/1481024304/</code> using regex to match the numeric ID:<br>
        <code>{service_name="nginx_access_log", host="appfelstrudel"} | json | status = "500" |~ "id/[0-9]+/"</code><br>
        The pattern <code>[0-9]+</code> matches one or more digits.
      </li>
      <li class="interactive" 
          data-reftarget='button[data-testid="data-testid RefreshPicker run button"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Run the regex query.</span>
        Click <strong>Run query</strong> to execute the regex query.
      </li>
    </ul>

    <p>Regex also has an exclude form: <code>!~</code> ("does not match").</p>
    <p>For example: <code>... !~ "200"</code> excludes lines that match the regex.</p>
  </span>

  <h2>7. üìà Metrics from Logs (Quick Teaser)</h2>

  <p>LogQL can also produce <strong>time series</strong> from logs. We'll keep this part short‚Äîthis is just to show what's possible.</p>
  <p>A good starting point is counting how many log lines match a query over time.</p>

  <span id="metrics-teaser" 
        class="interactive" 
        data-targetaction="sequence" 
        data-reftarget="span#metrics-teaser">
    <ul>
      <li class="interactive" 
          data-reftarget="textarea.inputarea"
          data-targetaction="formfill" 
          data-targetvalue='count_over_time({service_name="nginx_access_log"}[5m])'
          data-requirements="exists-reftarget">
        <span class="interactive-comment"><code>count_over_time(&lt;log query&gt;[5m])</code> counts how many log lines matched within each rolling 5-minute window. This returns a time series you can graph.</span>
        Type a simple metric query to count logs over time:<br>
        <code>count_over_time({service_name="nginx_access_log"}[5m])</code>
      </li>
      <li class="interactive" 
          data-reftarget='button[data-testid="data-testid RefreshPicker run button"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Run the metric query to see a chart.</span>
        Click <strong>Run query</strong> to see the count over time.
      </li>
      <li class="interactive" 
          data-reftarget="textarea.inputarea"
          data-targetaction="formfill" 
          data-targetvalue='sum by (host) (rate({service_name="nginx_access_log"}[5m]))'
          data-requirements="exists-reftarget">
        <span class="interactive-comment"><code>rate(...)</code> turns counts into "per-second" rate. <code>sum by (host)(...)</code> groups results by a label (here: host). This is a very common pattern for dashboards.</span>
        Optional: get a per-host rate (logs/second) using <code>rate</code> and <code>sum by</code>:<br>
        <code>sum by (host) (rate({service_name="nginx_access_log"}[5m]))</code>
      </li>
      <li class="interactive" 
          data-reftarget='button[data-testid="data-testid RefreshPicker run button"]'
          data-targetaction="highlight"
          data-requirements="exists-reftarget">
        <span class="interactive-comment">Run the per-host rate query.</span>
        Click <strong>Run query</strong> to see the per-host rate.
      </li>
    </ul>
  </span>

  <h2>8. ‚úÖ Wrap-up</h2>

  <p>You now know a practical workflow for writing LogQL:</p>
  <ol>
    <li><strong>Start with labels</strong> (fast, narrows data)</li>
    <li>Add <strong>simple filters</strong> (<code>|=</code>, <code>!=</code>) when needed</li>
    <li>Prefer <strong>structured parsing</strong> (<code>| json</code>) for precision</li>
    <li>Use <strong><code>line_format</code></strong> to make results readable</li>
    <li>Use <strong>regex</strong> (<code>|~</code>, <code>!~</code>) only when you can't parse</li>
    <li>Convert logs to <strong>metrics</strong> with <code>count_over_time</code> / <code>rate</code> for charts</li>
  </ol>
  <p>If you'd like, the next tutorial can go deeper on metrics (more functions, grouping, and common dashboard patterns).</p>

</body>
</html>
