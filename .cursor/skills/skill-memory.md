# Skill Memory Convention

A reusable pattern for skills that produce persistent analysis artifacts and may be re-run on the same input later. Skills that opt in can detect prior runs, compare input drift, and reuse unchanged artifacts rather than starting from scratch.

---

## The `assets/` Directory Convention

The skill's deliverable lives at the output directory root. Everything in `assets/` is skill-internal context — not consumed by the end product.

```
{output_dir}/
  {deliverable}           ← the product
  assets/
    manifest.yaml         ← entry point for re-run detection
    {analysis-files}      ← skill-internal artifacts
```

`assets/` files are tagged as auto-generated and should not be edited manually. They are skill memory — the record of a prior execution.

---

## Manifest Schema

Every skill using skill memory writes `assets/manifest.yaml`. Required core fields:

```yaml
# Auto-generated by {skill_name}. Do not edit manually.
schema_version: 1
skill_name: "{skill-name}"
generated_at: "{ISO 8601 timestamp}"
input_sha256: "{hex digest of hashed input fields}"

files:
  {artifact_key}: "assets/{filename}"
  ...
```

Skills add domain-specific fields beyond this core (e.g., panel counts, section IDs, quality metrics). Those fields are skill-specific and documented in the skill's own SKILL.md.

### Hashing the Input

Hash only the fields that matter for detecting meaningful drift — not the full input file. Cosmetic changes (default time ranges, color overrides, annotation settings) should not trigger re-extraction. Use `jq` or equivalent to extract the relevant fields before hashing:

```bash
jq -c '{relevant_fields}' {input_file} | shasum -a 256
```

Document the exact `jq` expression in the skill's SKILL.md so maintenance runs use the same hash method.

---

## Frontmatter Disclaimer

Every generated markdown file in `assets/` must start with:

```markdown
---
disclaimer: Auto-generated by {skill_name}. Do not edit manually.
notice: To regenerate, re-run the skill.
input_sha256: {hex digest}
---
```

Skills may add additional frontmatter fields relevant to their domain (e.g., `dashboard: {uid}`, `dashboardTitle: {title}`).

---

## Phase 0: Check for Prior Run

When a skill is invoked, before starting a full generation pipeline:

1. Check whether `{output_dir}/assets/manifest.yaml` exists
2. If it does: read the manifest, extract `input_sha256` and `generated_at`
3. Re-hash the current input using the same method as the original run
4. Compare hashes:
   - **Match** → no drift; skip re-extraction, offer to go straight to review or re-generate a specific section
   - **Mismatch** → drift detected; proceed with delta-aware re-run (use prior artifacts as warm start, not a fresh start)
5. If manifest does not exist: fresh run — proceed with the full generation pipeline

```
manifest.yaml exists?
  No  → full generation pipeline
  Yes → re-hash input
          matches stored hash?
            Yes → skip extraction, warm-start from assets/
            No  → delta extraction (prior artifacts as warm start)
```

---

## Implementing Skill-Specific Maintenance

The Phase 0 check is the same for all skills. What differs:

- **What is hashed** — skill documents the exact `jq` expression or field list
- **What "delta" means** — skill-specific: added panels, changed functions, modified schema, etc.
- **Which artifacts to reuse vs. regenerate** — depends on what changed

Each skill that uses this convention documents its maintenance flow separately. The generic convention defines the contract (manifest schema, frontmatter, assets/ layout, Phase 0 logic); the skill provides the implementation.
