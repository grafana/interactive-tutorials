{
  "id": "introduction-to-tracing-lab2-traceql-queries",
  "title": "2.2. Querying with TraceQL",
  "blocks": [
    {
      "type": "markdown",
      "content": "# 2.2. Querying with TraceQL\n\nNow you've seen how to carry out basic searches on Tempo data, it's time to get more hands-on with TraceQL itself.\n\n## The Span Selector\n\nTraceQL is built up of span selectors. Everything between opening and closing curly braces (`{}`) denotes characteristics of a span. Grafana Cloud Traces will find any spans in traces that match those selectors, and return those traces and spans as the results. Let's start with some basics to give you the idea, then build them up."
    },
    {
      "type": "markdown",
      "content": "The most basic query of all is just an empty span selector, `{}`, which simply says \"Find me any spans stored by Tempo, as well as the traces they belong to\". Try it now by entering it as the query in the TraceQL editor. Grafana will render the list of the first 20 traces that Grafana Cloud Traces, powered by Tempo, returned to it."
    },
    {
      "type": "image",
      "src": "img/2-empty-span-selector.png",
      "alt": "Empty span selector"
    },
    {
      "type": "markdown",
      "content": "We can change the number of returned traces that match (up to 1000), and the number of spans per trace returned. **1.** Change the number of returned spans for each trace to 10, by expanding the `Search Options` and modifying the `Span Limit` to 10 (no need to change the number of returned traces for now)."
    },
    {
      "type": "image",
      "src": "img/2-span-limits.png",
      "alt": "Span limits"
    },
    {
      "type": "markdown",
      "content": "Hide the `Search Options` again after you've made the change to give yourself a little more space again. Re-run the query by selecting `Run query` (or hitting `Shift-Enter` on your keyboard). Now expand the span list for several traces. You'll find that instead of a maximum of 3 returned spans per trace, some have considerably more!\n\n\n**2.** Start a new query by entering the following into the TraceQL query editor:\n\n```\n{ resource.service.name = \"productcatalogservice\" }\n```\n\nand then select `Run query`. Grafana will render the list of results, and again you can expand an individual trace to see all matching spans (in this case, any span that belongs to the `productcatalogservice` service). It's also again worth noting that the results returned are *any* span that matches the selector. Therefore you might see multiple spans returned in the same trace if there are more than one that was generated by the `productcatalogueservice` as part of a request."
    },
    {
      "type": "image",
      "src": "img/2-span-result.png",
      "alt": "Span results"
    },
    {
      "type": "markdown",
      "content": "Note that the service name is part of the resource attributes, which is why `service.name` is prefixed with `resource`. You can also search for span attributes, which are the more commonly useful attributes for the context of the work that a span is representing. To do that, just prefix the span attribute name with `span`. Try running the following TraceQL query:\n\n```\n{ span.http.method = \"GET\" }\n```\n\nYou'll see a list of results where every matched span for the trace has a `http.method` column with the value set to `GET`."
    },
    {
      "type": "markdown",
      "content": "## Unscoped attributes\n\nYou may know that an attribute exists, but not if it is a span or resource attribute. You can use unscoped attribute querying in TraceQL for this, by simply omitting the type of attribute by just using `.`. This will force TraceQL to look for the given attribute in both span and resource scopes. For example:\n\n```\n{ .service.name = \"productcatalogservice\" && .rpc.method = \"ListProducts\" }\n```"
    },
    {
      "type": "image",
      "src": "img/2-unscoped-attributes.png",
      "alt": "Unscoped attribute queries"
    },
    {
      "type": "markdown",
      "content": "Bear in mind that queries with unscoped attributes require extra work on the part of Tempo to look at both attribute stores; this may not be as performant as when you explicitly scope attributes."
    },
    {
      "type": "markdown",
      "content": "## Multi-attribute selectors and pipelining\n\nYou've now carried out a more in-depth TraceQL query using a span selector with two fields.\n\nThis leads to another interesting topic; we might not initially know all of the different values that a particular attribute may have, so to actually determine what to dig into, we can help ourselves by also returning a list of values that are available for that attribute. **1.** Run the following query:\n\n```\n{ resource.service.name = \"productcatalogservice\" } | select(span.rpc.method)\n```\n\nWhilst this query will only look for matches of the `productcatalogservice` service name, the `select` function will also show us the values for any `span.rpc.method` attributes that may exist on any matching spans. This TraceQL query also introduces another concept we discussed in the workshop, pipelining. This allows you to forward the resulting list of spans from traces that match the span selector into other TraceQL functions. `select` can take multiple parameters for the attributes or intrinsics you want the results to return."
    },
    {
      "type": "image",
      "src": "img/2-select.png",
      "alt": "Selecting attributes"
    },
    {
      "type": "markdown",
      "content": "Whilst you've seen there can be different values for the `rpc.method` attribute. **2.** You can create a new TraceQL query that only looks for matching spans whose attributes match a regex:\n\n```\n{ resource.service.name = \"productcatalogservice\" && span.rpc.method =~ \"Get.+|List.+\"}\n```\n\nThis will return spans for the `productcatalogservice` which have an `rpc.method` span attribute that starts either with `Get` *or* `List`.\n\nComparators can also be used to filter on attributes which are numeric. **3.** Extend out the search so that Tempo only looks for traces where a span has a GET or POST that has an `http.status_code` attribute greater than 499 (ie. an internal server error):\n\n```\n{ span.http.method =~ \"POST|GET\" && span.http.status_code > 499 }\n```"
    },
    {
      "type": "image",
      "src": "img/2-http-status-code-error.png",
      "alt": "HTTP Status code error"
    },
    {
      "type": "markdown",
      "content": "Note that whilst you've used the `&&` operator for ANDing attributes where both must match to satisfy the constraints, you could also use the `||` operator to create a union, ORing the two constraints together."
    },
    {
      "type": "markdown",
      "content": "## Multi-span selectors\n\nSo far you've only used a single span selector in a query. You can actually look for traces that satisfy multiple, separate span characteristics by using multiple span selectors in a query. By again using logical spanset operations `&&` (AND) and `||` (OR) in a similar way to that in a single span selector, we can test multiple spans in the same query.\n\n\n**1.** Run the following TraceQL query:\n\n```\n{ span.http.method = \"POST\" } || { span.rpc.method = \"ListProducts\" }\n```"
    },
    {
      "type": "image",
      "src": "img/2-multi-span-selector-or.png",
      "alt": "Multiple span selectors OR"
    },
    {
      "type": "markdown",
      "content": "This will return results if it finds a trace where either span selector matches the constraint.\n\nNote that the query is using two span attributes that are mutually exclusive to each other, ie. they cannot both exist in the same span at once. If we were querying for attributes that co-existed in the same span, or using the same attribute in both span selectors, it is far more efficient to write a query using a single span selector.\n\n\n**2.** In the case of span selectors joined using the union operator, Tempo will separately evaluate all of the individual span selectors in a trace for spans whose constraints. In the case of the AND operator, at least one span matching each constraint is required. Replacing the OR operator with an AND operator will ensure that both span selectors must match spans to return results. Enter the following into the editor and then run the query:\n\n```\n{ span.http.method = \"POST\" } && { span.http.method = \"GET\" }\n```"
    },
    {
      "type": "image",
      "src": "img/2-and-selectors.png",
      "alt": "AND selector"
    },
    {
      "type": "markdown",
      "content": "There are far fewer results returned, because there are not very many traces that have multiple spans with an `http.method` attribute with both `POST` and `GET` methods, but there are at least two spans returned for each result."
    },
    {
      "type": "markdown",
      "content": "## Intrinsics\n\nMost of the previous queries used span attributes, but there are many intrinsics of a span (and trace) that can also be queried to return relevant trace results. These are called intrinsics, and describe the behaviour of a span or trace. For example, the total duration of a span is denoted by `span:duration`, whereas the total duration of a trace all of its spans belong to is denoted with `trace:duration`.\n\n\n**1.** Look for any traces that are over a second long by using the following TraceQL query:\n\n```\n{ trace:duration > 1s }\n```\n\nYou'll see in the results that the trace duration for all results are greater than 1 second, but the individual spans returned are all under. This is because *any* span in a trace longer than 1 second long is a valid match for the returned traces.\n\n\n**2.** In the Traces Drilldown breakout, you searched for traces of interest that were exhibiting errors. We can start to do the same here using the `span:status` intrinsic, by running the following query:\n\n```\n{ resource.service.name = \"productcatalogservice\" && span:status = error }\n```"
    },
    {
      "type": "image",
      "src": "img/2-intrinsic-selectors.png",
      "alt": "Intrinsic selectors"
    },
    {
      "type": "markdown",
      "content": "By using intrinsics, we can start to narrow down traces and spans of interest to us by using both span and trace intrinsics."
    },
    {
      "type": "markdown",
      "content": "## Structural Operators\n\nTraceQL also includes structural operators. These allow you to craft queries that inspect the hierarchy of a span for a trace. This includes testing spans in traces for other spans that are children (or parents) of the span, that may be descendents (or antecedents) of the span somewhere further down the hierarchy of the trace, or are siblings of the span.\n\n\n**1.** For example, perhaps you're interested in any span that calls across services, so let's craft some TraceQL that looks for that specifically, with an upstream call and a downstream call from one service that I know should be calling another:\n\n```\n{ resource.service.name = \"ditl-demo-frontend-client\" } >> { resource.service.name = \"currencyservice\" }\n```"
    },
    {
      "type": "image",
      "src": "img/2-descendant-operator.png",
      "alt": "Descendent operator"
    },
    {
      "type": "markdown",
      "content": "`>>` is an example of a structural operator. In this case, TraceQL will return any traces where a span generated in the `ditl-demo-frontend-client` service is upstream (ie. is an antecedents) of another span generated in the currencyservice service, further downstream. We could also specify a direct parent/child hierarchy by using a single angle bracket instead:\n\n```\n{ resource.service.name = \"ditl-demo-frontend-client\" } > { resource.service.name = \"currencyservice\" }\n```\n\nIn this case, we yield no results because there are services in the parent hierarchy between the frontend service and the payment service.\n\n\n**2.** For many interesting traces exhibiting errors, it's useful to find the last span in the trace that shows an error. The correct query is:\n\n```\n{ } !< { resource.service.name = \"productcatalogservice\" && span:status = error }\n```"
    },
    {
      "type": "image",
      "src": "img/2-structural-antescendent.png",
      "alt": "Structural error antescendent"
    },
    {
      "type": "markdown",
      "content": "This allows you to find the `productcatalogservice` spans with an error set, that are not antecedents of any other span. This returns us the results we expect."
    },
    {
      "type": "markdown",
      "content": "## Aggregators\n\nAggregators are functions that let us look over a set of spans and carryout our numerical operations on them.\n\n\n**1.** We can, for example, see if any of our traces have a certain number of spans that satisfy an aggregation condition. This example will return all traces where the total number of GET or DELETE spans in a trace is greater than four occurrences:\n\n```\n{ span.http.method =~ \"GET|DELETE\" } | count() > 4\n```\n\nNote that we have also increased the default limit of spans returned for each trace in the results from 3 to 10.\n\n\n**2.** We could be looking for latencies on a trace again, and want to see any traces where the average duration of the collection of matching spans is over 10ms:\n\n```\n{ resource.service.name = \"productcatalogservice\" } | avg(span:duration) > 2ms\n```\n\n\n**3.** We could apply min or max to this as well, for example, to find traces where the minimum of each span individually is 100ms:\n\n```\n{ resource.service.name = \"productcatalogservice\" } | min(span:duration) > 10ms\n```"
    },
    {
      "type": "markdown",
      "content": "## Summary\n\nIn this section, you've learnt how to carry out TraceQL queries from a single span selector with a single field to multi-span selector queries that use multiple attributes and intrinsics as well as pipelining to functions.\n\nIn the next section, we'll look at writing TraceQL metrics queries, which return time-series data that can be visualised by Grafana."
    }
  ]
}
