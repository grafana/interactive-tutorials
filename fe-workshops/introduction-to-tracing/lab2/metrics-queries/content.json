{
  "id": "introduction-to-tracing-lab2-metrics-queries",
  "title": "2.3. TraceQL Metrics",
  "blocks": [
    {
      "type": "markdown",
      "content": "# 2.3. TraceQL Metrics\n\nSo far you've used pipelining to put queries together for aggregate and data selection functions, but we also use it for passing span data to TraceQL's metrics functions.\n\nTraceQL metrics allow you to quickly visualise spans, their attributes and intrinsics as time-series data.\n\nEarlier, you used a select statement to find all the possible rpc methods that might be called from a service:\n\n```\n{ resource.service.name = \"productcatalogservice\" } | select(span.rpc.method)\n```\n\nWhilst this is useful, there might be a myriad of statements, and looking through every trace to find the combinations would be a time-consuming process."
    },
    {
      "type": "markdown",
      "content": "It would be far more useful to get an idea of not only the methods that were used, but also how *often* they were used.\n\n**1.** Enter the following TraceQL query into the editor:\n\n```\n{ resource.service.name = \"productcatalogservice\" } | count_over_time()\n```"
    },
    {
      "type": "image",
      "src": "img/3-count-over-time.png",
      "alt": "count_over_time"
    },
    {
      "type": "markdown",
      "content": "Rather than returning a list of traces and spans containing RPC methods, Tempo returns time-series data, which Grafana then visualizes as a graph showing the number of RPC calls made over each time interval (with a default interval of 15 seconds, which determines the frequency of data points on the time-series graph).\n\nYou can change the time-step for TraceQL metrics by opening the `Metrics Options` dialogue under the TraceQL query editor and changing the `Step` value from `auto` to a time-step you want to use. Try different values to see what happens (perhaps `15s`, `1m`, and `5m`)."
    },
    {
      "type": "markdown",
      "content": "Whilst this graph is immediately useful to see how often RPC methods are being called in the `productcatalogservice`, it doesn't separate these out by unique method name.\n\n**2.** Therefore, to group the rate of calls by unique RPC method, you need to add the `by` function to inform Tempo how to group the results. Alter the query to the following and then re-run the query:\n\n```\n{ resource.service.name = \"productcatalogservice\" } | count_over_time() by (span.rpc.method,span:name)\n```"
    },
    {
      "type": "image",
      "src": "img/3-count-over-time-by.png",
      "alt": "count_over_time with by"
    },
    {
      "type": "markdown",
      "content": "Note the small diamonds in the time-series graph returned. These are called `exemplars` and they are correlatable links to specific traces that exhibit the value that the diamond represents. Observing the traces they represent can be extremely useful in situations where the values deviate from the average.\n\nThe `by` operator will act upon a function to group results from the preceeding function, and can take multiple attribute or intrinsic property names which will affect the grouping. `by` can be used with all of the TraceQL metrics functions to allow grouping (and add labels for each) of the returned time-series results."
    },
    {
      "type": "markdown",
      "content": "Now you'll see multiple coloured lines on the graph, one for each unique RPC call, as well as `nil`. Whilst maybe confusing at first, the `nil` is present because the `count_over_time` function is counting *any* span generated by the `productcatalogservice`, because the span selector only has that service as a constraint to found spans. Some of these may not have RPC method calls at all! To only see data from spans that include the `rpc.method` attribute, ensure that the span selector includes a relevant constraint. We *could* narrow the span selector constraint. A better query may be to change `by (span.rpc.method)` to `by (span.rpc.method,span:name)`. The returned time-series data will be grouped by unique RPC and span name instrinsic combinations.\n\n**3.** Try doing this now and running the query. You should see the following:"
    },
    {
      "type": "image",
      "src": "img/3-count-over-time-by-spanname.png",
      "alt": "count_over_time with multiple by"
    },
    {
      "type": "markdown",
      "content": "TraceQL metrics include a number of different functions, many of them relating to their relevant PromQL namesakes (PromQL being Prometheus' querying language).\n\n**4.** For example, to see the per-second rate of the number of occurrences of HTTP codes from a specific service over a time-step, enter the following in the TraceQL editor:\n\n```\n{ resource.service.name = \"frontend\" && span.http.status_code != nil } | rate() by (span.http.status_code)\n```"
    },
    {
      "type": "image",
      "src": "img/3-rate-http-code.png",
      "alt": "HTTP status code rate"
    },
    {
      "type": "markdown",
      "content": "TraceQL metrics also supports quantiles and histograms, so you can also return latency data for matching spans.\n\n**5.** For example the 95th percentile of specific calls:\n\n```\n{ span:name =~ \"GET.+\" } | quantile_over_time(span:duration, 0.95) by (span.http.target)\n```"
    },
    {
      "type": "image",
      "src": "img/3-quantile-over-time.png",
      "alt": "quantile_over_time"
    },
    {
      "type": "markdown",
      "content": "Along with the results, it'll also return exemplars so you can dive into particular traces that are exhibiting long durations.\n\nChange the time-range over which the TraceQL metrics query runs by modifying it in the Time Picker at the top-right of the Explore panel."
    },
    {
      "type": "image",
      "src": "img/3-time-picker.png",
      "alt": "The time picker"
    },
    {
      "type": "markdown",
      "content": "There's a lot of different functions for returning metric data from your traces, and of course, because all these functions work to return metric values, you can also easily embed these queries into dashboard panels and choose the visualization of your choice to do so.\n\n## Summary\n\nIn this section, you've learned how to take TraceQL queries and pipe them into metrics functions, returning useful time-series data that can be visualised as graphs and heatmaps. These can also be added in dashboard panels, allowing you to visualise the data in a way that suits you.\n\nThat's the end of this lab!"
    }
  ]
}
